import { GdcFile, Token } from "../../parse/binary/gdc.js";
import { TokenType } from "../../parse/binary/gdc_tokens.js";
import { Precedence } from "./rules.js";
import { AnnotationInfo_TargetKind, AnnotationNode, AssertNode, BreakNode, ClassMemberSource, ClassNode, ConstantNode, ContinueNode, EnumNode, EnumValue, ExpressionNode, ForNode, FunctionNode, IdentifierNode, IfNode, LambdaNode, MatchBranchNode, MatchNode, Node, ParameterNode, PatternNode, SignalNode, SuiteNode, TypeNode, VariableNode, WhileNode } from "./type.js";
export declare class Tokenizer {
    current: number;
    current_line: number;
    pending_indents: number;
    last_token_was_newline: boolean;
    indent_stack: number[];
    indent_stack_stack: number[][];
    multiline_mode: boolean;
    private tokens;
    private token_lines;
    private token_columns;
    constructor(gdcFile: GdcFile);
    scan(): Token;
}
export declare class BinaryParser {
    private tokenizer;
    script_path: string;
    head?: ClassNode;
    current_class: ClassNode | null;
    current_function: FunctionNode | null;
    current_lambda: LambdaNode | null;
    current_suite: SuiteNode | null;
    index: number;
    can_break: boolean;
    can_continue: boolean;
    in_lambda: boolean;
    lambda_ended: boolean;
    annotation_stack: AnnotationNode[];
    multiline_stack: boolean[];
    current: Token;
    previous: Token;
    constructor(tokenizer: Tokenizer, script_path: string);
    advance(): Token;
    match(type: TokenType): boolean;
    get is_multiline(): boolean;
    check(type: TokenType): boolean;
    consume(p_token_type: TokenType, p_error_message: string): boolean;
    is_at_end(): boolean;
    is_statement_end_token(): boolean;
    is_statement_end(): boolean;
    end_statement(p_context: string): void;
    push_multiline(p_state: boolean): void;
    pop_multiline(): void;
    parse(): ClassNode | undefined;
    parse_program(): void;
    parse_class(_p_is_static: boolean): ClassNode | null;
    parse_class_name(): void;
    parse_extends(): void;
    parse_class_member<T extends Exclude<ClassMemberSource, AnnotationNode | EnumValue | undefined>>(p_parse_function: (is_static: boolean) => T | null, p_target: AnnotationInfo_TargetKind, p_member_kind: string, p_is_static?: boolean): void;
    parse_class_body(p_is_multiline: boolean): void;
    parse_variable(p_is_static: boolean, p_allow_property?: boolean): VariableNode | null;
    parse_property(p_variable: VariableNode, p_need_indent: boolean): VariableNode | null;
    parse_property_setter(p_variable: VariableNode): void;
    parse_property_getter(p_variable: VariableNode): void;
    parse_constant(_p_is_static: boolean): ConstantNode | null;
    parse_parameter(): ParameterNode | null;
    parse_signal(_p_is_static: boolean): SignalNode | null;
    parse_enum(_p_is_static: boolean): EnumNode | null;
    parse_function_signature(p_function: FunctionNode, p_body: SuiteNode, p_type: string): void;
    parse_function(p_is_static: boolean): FunctionNode | null;
    parse_annotation(p_valid_targets: number): AnnotationNode | null;
    clear_unused_annotations(): void;
    parse_suite(p_context: string, p_suite?: SuiteNode | null, p_for_lambda?: boolean): SuiteNode | null;
    parse_statement(): Node | null;
    parse_assert(): AssertNode | null;
    parse_break(): BreakNode;
    parse_continue(): ContinueNode;
    parse_for(): ForNode;
    parse_if(p_token?: string): IfNode | null;
    parse_match(): MatchNode;
    parse_match_branch(): MatchBranchNode | null;
    parse_match_pattern(p_root_pattern?: PatternNode | null): PatternNode | null;
    parse_while(): WhileNode;
    parse_precedence(p_precedence: Precedence, p_can_assign: boolean, p_stop_on_assign?: boolean): ExpressionNode | null;
    parse_expression(p_can_assign: boolean, p_stop_on_assign?: boolean): ExpressionNode | null;
    parse_identifier(_p_previous_operand?: ExpressionNode | null, _p_can_assign?: boolean): IdentifierNode;
    parse_literal(_p_previous_operand: ExpressionNode | null, _p_can_assign: boolean): ExpressionNode | null;
    parse_self(_p_previous_operand: ExpressionNode | null, _p_can_assign: boolean): ExpressionNode | null;
    parse_builtin_constant(_p_previous_operand: ExpressionNode | null, _p_can_assign: boolean): ExpressionNode | null;
    parse_unary_operator(_p_previous_operand: ExpressionNode | null, _p_can_assign: boolean): ExpressionNode | null;
    parse_binary_not_in_operator(p_previous_operand: ExpressionNode | null, p_can_assign: boolean): ExpressionNode | null;
    parse_binary_operator(p_previous_operand: ExpressionNode | null, _p_can_assign: boolean): ExpressionNode | null;
    parse_ternary_operator(p_previous_operand: ExpressionNode | null, _p_can_assign: boolean): ExpressionNode;
    parse_assignment(p_previous_operand: ExpressionNode | null, p_can_assign: boolean): ExpressionNode | null;
    parse_await(_p_previous_operand: ExpressionNode | null, _p_can_assign: boolean): ExpressionNode | null;
    parse_array(_p_previous_operand: ExpressionNode | null, _p_can_assign: boolean): ExpressionNode | null;
    parse_dictionary(_p_previous_operand: ExpressionNode | null, _p_can_assign: boolean): ExpressionNode | null;
    parse_grouping(_p_previous_operand: ExpressionNode | null, _p_can_assign: boolean): ExpressionNode | null;
    parse_attribute(p_previous_operand: ExpressionNode | null, _p_can_assign: boolean): ExpressionNode | null;
    parse_subscript(p_previous_operand: ExpressionNode | null, _p_can_assign: boolean): ExpressionNode | null;
    parse_cast(p_previous_operand: ExpressionNode | null, _p_can_assign: boolean): ExpressionNode | null;
    parse_call(p_previous_operand: ExpressionNode | null, _p_can_assign: boolean): ExpressionNode | null;
    parse_get_node(_p_previous_operand: ExpressionNode | null, _p_can_assign: boolean): ExpressionNode | null;
    parse_preload(_p_previous_operand: ExpressionNode | null, _p_can_assign: boolean): ExpressionNode | null;
    parse_lambda(_p_previous_operand: ExpressionNode, _p_can_assign: boolean): ExpressionNode | null;
    parse_type_test(p_previous_operand: ExpressionNode | null, _p_can_assign: boolean): ExpressionNode | null;
    parse_yield(_p_previous_operand: ExpressionNode | null, _p_can_assign: boolean): ExpressionNode | null;
    parse_invalid_token(p_previous_operand: ExpressionNode | null, _p_can_assign: boolean): ExpressionNode | null;
    parse_type(p_allow_void?: boolean): TypeNode | null;
}
